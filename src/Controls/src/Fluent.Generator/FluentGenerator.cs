using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Maui.Controls.Fluent.Generator
{
	public class FluentGenerator
	{
		public const string FluentInterfaceAttributeString = "FluentInterfaceAttribute";
		public const string BindablePropertiesAttributeString = "BindablePropertiesAttribute";

		GeneratorExecutionContext context;

		public static string[] notGenerateList = { "this[]", "Handler", "LogicalChildren" };

		public FluentGenerator(GeneratorExecutionContext context)
		{
			this.context = context;
		}

		public bool IsPublicBindableObjectWithConstructor(ISymbol symbol)
		{
			bool isViewObject = false;
			var namedSymbol = symbol as INamedTypeSymbol;

			if (namedSymbol != null &&
				namedSymbol.TypeKind == TypeKind.Class &&
				!namedSymbol.IsGenericType &&
				!namedSymbol.IsAbstract &&
				namedSymbol.DeclaredAccessibility == Accessibility.Public &&
				namedSymbol.ToDisplayString().StartsWith("Microsoft.Maui.Controls") &&
				namedSymbol.Constructors.FirstOrDefault(e => e.DeclaredAccessibility == Accessibility.Public) != null &&
				namedSymbol.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals("ObsoleteAttribute", StringComparison.Ordinal)) == null)
			{

				Helpers.LoopDownToObject(namedSymbol, type =>
				{
					isViewObject = type.ToDisplayString().Equals("Microsoft.Maui.Controls.BindableObject", StringComparison.Ordinal);
					return isViewObject;
				});
			}
			return isViewObject;
		}

		public static bool IsFluentObject(ISymbol symbol)
		{
			var namedSymbol = symbol as INamedTypeSymbol;
			if (namedSymbol != null)
			{
				var attributes = symbol.GetAttributes();
				return attributes.FirstOrDefault(e => e.AttributeClass.Name.Equals(FluentInterfaceAttributeString, StringComparison.Ordinal)) != null;
			}
			return false;
		}

		List<INamedTypeSymbol> symbolsWithAttribute;
		List<INamedTypeSymbol> mauiSymbols;
		List<INamedTypeSymbol> symbolsToGenerate;
		List<INamedTypeSymbol> parentSymbols;

		void GenerateSymbolLists()
		{
			mauiSymbols = context.Compilation.GetSymbolsWithName((s) => true, filter: SymbolFilter.Type)
				.Where(IsPublicBindableObjectWithConstructor).Select(e => (INamedTypeSymbol)e).ToList();

			symbolsWithAttribute = context.Compilation.GetSymbolsWithName((s) => true, filter: SymbolFilter.Type)
				.Where(IsFluentObject).Select(e => (INamedTypeSymbol)e).ToList();

			symbolsToGenerate = new List<INamedTypeSymbol>();
			symbolsToGenerate.AddRange(mauiSymbols);
			foreach (var symbol in symbolsWithAttribute)
				if (!symbolsToGenerate.Contains(symbol)) symbolsToGenerate.Add(symbol);

			parentSymbols = new List<INamedTypeSymbol>();
			foreach (var symbol in symbolsToGenerate)
			{
				Helpers.LoopDownToObject(symbol.BaseType, type =>
				{
					if (IsFluentObject(type) && !type.IsGenericType) return true;
					if (!parentSymbols.Contains(type) && !symbolsToGenerate.Contains(type))
						parentSymbols.Add(type);
					return false;
				});
			}

			var allSymbols = new List<INamedTypeSymbol>();
			allSymbols.AddRange(symbolsToGenerate);
			allSymbols.AddRange(parentSymbols);
			var sealedSymbols = allSymbols.Where(e => e.IsSealed).ToList();
			sealedSymbols.Sort((a, b) => a.ToDisplayString().CompareTo(b.ToDisplayString()));

			GenerateInfoFile(sealedSymbols, "_sealedSymbols.g.cs", true);
		}

		void ListSymbols()
		{
			mauiSymbols.Sort((a, b) => a.ToDisplayString().CompareTo(b.ToDisplayString()));
			symbolsToGenerate.Sort((a, b) => a.ToDisplayString().CompareTo(b.ToDisplayString()));
			symbolsWithAttribute.Sort((a, b) => a.ToDisplayString().CompareTo(b.ToDisplayString()));
			parentSymbols.Sort((a, b) => a.ToDisplayString().CompareTo(b.ToDisplayString()));

			GenerateInfoFile(mauiSymbols, "_mauiSymbols.g.cs");
			GenerateInfoFile(symbolsWithAttribute, "_symbolsWithAttribute.g.cs");
			GenerateInfoFile(symbolsToGenerate, "_symbolsToGenerate.g.cs");
			GenerateInfoFile(parentSymbols, "_parentSymbols.g.cs");
		}

		public void Generate()
		{
			GenerateSymbolLists();
			ListSymbols();

			foreach (var symbol in symbolsToGenerate)
			{
				new ClassGenerator(context, symbol).Build();
				if (!symbol.IsGenericType)
					new ExtensionGenerator(context, symbol).Build();
			}
			foreach (var symbol in parentSymbols)
			{
				new ExtensionGenerator(context, symbol).Build();
			}
		}

		void GenerateInfoFile(IEnumerable<ISymbol> symbols, string fileName, bool regExp = false)
		{
			var builder = new StringBuilder();
			builder.AppendLine("//");
			builder.AppendLine("// <auto-generated>");
			builder.AppendLine("//");
			builder.AppendLine("/*");
			builder.AppendLine();
			if (regExp)
			{
				builder.Append("public (sealed class |sealed partial class )(");
				var first = true;
				foreach (var symbol in symbols)
				{
					builder.Append($"{(first ? "" : "|")}{symbol.Name}");
					first = false;
				}
				builder.AppendLine(")( |\\n)");
			}

			builder.AppendLine();
			builder.AppendLine($"Count {symbols.Count()}");
			builder.AppendLine();

			foreach (var symbol in symbols)
				builder.AppendLine($"{symbol.ToDisplayString()}");

			builder.AppendLine();
			builder.AppendLine("*/");

			context.AddSource(fileName, builder.ToString());
		}
	}
}