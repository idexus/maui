using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Microsoft.Maui.Controls.Fluent.Generator
{
	public class ExtensionGenerator
	{
		GeneratorExecutionContext context;
		INamedTypeSymbol symbol;

		StringBuilder builder;
		bool isExtensionMethodsGenerated;

		public ExtensionGenerator(GeneratorExecutionContext context, INamedTypeSymbol symbol)
		{
			this.context = context;
			this.symbol = symbol;
		}

		public void Build()
		{
			isExtensionMethodsGenerated = false;
			builder = new StringBuilder();
			builder.AppendLine("//");
			builder.AppendLine("// <auto-generated>");
			builder.AppendLine("//");
			builder.AppendLine();

			builder.AppendLine("#nullable enable");
			builder.AppendLine("#pragma warning disable CS8601");
			builder.AppendLine();

			GenerateExtensionNameSpace();

			builder.AppendLine();
			builder.AppendLine("#pragma warning restore CS8601");
			builder.AppendLine("#nullable restore");

			if (isExtensionMethodsGenerated)
				context.AddSource($"{symbol.ContainingNamespace.ToDisplayString()}.{Helpers.GetNormalizedName(symbol)}.extension.g.cs", builder.ToString());
		}

		void GenerateExtensionNameSpace()
		{
			builder.Append($@"
namespace {symbol.ContainingNamespace.ToDisplayString()}
{{
	using Microsoft.Maui.Controls.Fluent;

    public static class {Helpers.GetNormalizedName(symbol)}GeneratedExtension
    {{");         
            GenerateClassExtensionBody();
            builder.AppendLine($@"
    }}
}}");
		}

		List<string> extensionBindablePropertiesGenerated;

		void GenerateClassExtensionBody()
		{
			extensionBindablePropertiesGenerated = new List<string>();
			var bindableProperties = symbol
					.GetMembers()
					.Where(e => e.IsStatic && e.Name.EndsWith("Property") && e.DeclaredAccessibility == Accessibility.Public).ToList();

			extensionBindablePropertiesGenerated.Clear();
			foreach (var prop in bindableProperties)
			{
				var name = prop.Name.Substring(0, prop.Name.Length - "Property".Length);
				extensionBindablePropertiesGenerated.Add(name);
			}

			var properties = symbol
				.GetMembers()
				.Where(e => e.Kind == SymbolKind.Property && e.DeclaredAccessibility == Accessibility.Public && !e.IsStatic);

			var events = symbol
				.GetMembers()
				.Where(e => e.Kind == SymbolKind.Event && e.DeclaredAccessibility == Accessibility.Public && !e.IsStatic);

			foreach (var prop in properties)
				GenerateExtensionMethod(prop as IPropertySymbol);

			foreach (var @event in events)
				GenerateEventMethod(@event);

			GenerateBindablePropertiesExtension();
		}

		
		class PropertyInfo
		{
			public IPropertySymbol propertySymbol;
			public readonly string propertyName;
			public readonly string bindablePropertyName;
			public readonly string accessedWith;
			public readonly string propertyTypeName;
			public readonly string camelCaseName;
			public readonly string symbolTypeName;

			public PropertyInfo(INamedTypeSymbol type, IPropertySymbol propertySymbol)
			{
				this.propertySymbol = propertySymbol;

				propertyName = propertySymbol.Name.Split(new[] { "." }, StringSplitOptions.None).Last();
				propertyName = propertyName.Equals("class", StringComparison.Ordinal) ? "@class" : propertyName;
				accessedWith = propertySymbol.IsStatic ? $"{type.ToDisplayString()}" : "obj";
				propertyTypeName = propertySymbol.Type.ToDisplayString();
				camelCaseName = Helpers.CamelCase(propertyName);
				bindablePropertyName = $"{type.ToDisplayString()}.{propertyName}Property";
				symbolTypeName = $"{type.ToDisplayString()}";
			}
		}

		bool ExistInBaseClasses(string propertyName, bool getterAndSetter)
		{
			var existInBaseClasses = false;
			Helpers.LoopDownToObject(symbol.BaseType, type =>
			{
				existInBaseClasses = (type
							.GetMembers()
							.FirstOrDefault(e =>
								e.Kind == SymbolKind.Property &&
								e.DeclaredAccessibility == Accessibility.Public &&
								(((IPropertySymbol)e).SetMethod != null || !getterAndSetter) &&
								e.Name.Equals(propertyName, StringComparison.Ordinal)) != null);

				return existInBaseClasses;
			});
			return existInBaseClasses;
		}

		// --------------------------------------------------
		// ----- bindable from interface fluent methods -----    
		// --------------------------------------------------

		void GenerateBindablePropertiesExtension()
		{
			// generate using bindable interface
			var interfaces = symbol
				.Interfaces
				.Where(e => e.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(FluentGenerator.BindablePropertiesAttributeString, StringComparison.Ordinal)) != null);

			foreach (var inter in interfaces)
			{
				var properties = inter
					.GetMembers()
					.Where(e => e.Kind == SymbolKind.Property);

				foreach (var prop in properties)
				{
					var propertySymbol = (IPropertySymbol)prop;
					var fullPropertyName = $"{symbol.ToDisplayString()}.{prop.Name}";
					GenerateExtensionMethodForBindable(propertySymbol);
				}
			}
		}

		void GenerateExtensionMethodForBindable(IPropertySymbol propertySymbol)
		{
			var info = new PropertyInfo(symbol, propertySymbol);
			if (!FluentGenerator.notGenerateList.Contains(info.propertyName))
			{
				GenerateExtensionMethod_Value(info);
				GenerateExtensionMethod_ValueBuilder(info);
				GenerateExtensionMethod_LazyValueBuilder(info);
				GenerateExtensionMethod_BindingBuilder(info);
			}
		}

		// -----------------------------------
		// ----- property fluent methods -----    
		// -----------------------------------

		void GenerateExtensionMethod(IPropertySymbol property)
		{
			var info = new PropertyInfo(symbol, property);
			if (!FluentGenerator.notGenerateList.Contains(info.propertyName))
			{
				if (info.propertySymbol.SetMethod != null &&
				info.propertySymbol.SetMethod.DeclaredAccessibility == Accessibility.Public &&
				!ExistInBaseClasses(info.propertyName, getterAndSetter: true))
				{
					GenerateExtensionMethod_Value(info);
					GenerateExtensionMethod_ValueBuilder(info);
					GenerateExtensionMethod_LazyValueBuilder(info);
					if (extensionBindablePropertiesGenerated.Contains(info.propertyName))
						GenerateExtensionMethod_BindingBuilder(info);
				}
				else
				{
					if (info.propertySymbol.Type is INamedTypeSymbol)
					{
						var propertyType = (INamedTypeSymbol)info.propertySymbol.Type;
						var isGenericIList = Helpers.IsGenericIList(propertyType, out var elementType);

						if (info.propertySymbol.GetMethod != null &&
							info.propertySymbol.GetMethod.DeclaredAccessibility == Accessibility.Public &&
							isGenericIList &&
							!ExistInBaseClasses(info.propertyName, getterAndSetter: false))
						{
							GenerateExtensionMethod_List(info, elementType.ToDisplayString());
						}
					}
				}
			}
		}

		void GenerateExtensionMethod_Value(PropertyInfo info)
		{
			if (symbol.IsSealed)
				GenerateExtensionMethod_Value_Sealed(info);
			else
				GenerateExtensionMethod_Value_Normal(info);
		}

		void GenerateExtensionMethod_Value_Sealed(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            {info.propertyTypeName} {info.camelCaseName})
        {{
            {info.accessedWith}.{info.propertyName} = {info.camelCaseName};
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_Value_Normal(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T {info.propertyName}<T>(this T obj,
            {info.propertyTypeName} {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            {info.accessedWith}.{info.propertyName} = {info.camelCaseName};
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_BindingBuilder(PropertyInfo info)
		{
			if (symbol.IsSealed)
				GenerateExtensionMethod_BindingBuilder_Sealed(info);
			else
				GenerateExtensionMethod_BindingBuilder_Normal(info);
		}

		void GenerateExtensionMethod_BindingBuilder_Sealed(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            System.Func<BindingBuilder<{info.propertyTypeName}>, BindingBuilder<{info.propertyTypeName}>> buidBinding)
        {{
            var builder = buidBinding(new BindingBuilder<{info.propertyTypeName}>(obj, {info.bindablePropertyName}));
            builder.BindProperty();
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_BindingBuilder_Normal(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T {info.propertyName}<T>(this T obj,
            System.Func<BindingBuilder<{info.propertyTypeName}>, BindingBuilder<{info.propertyTypeName}>> buidBinding)
            where T : {info.symbolTypeName}
        {{
            var builder = buidBinding(new BindingBuilder<{info.propertyTypeName}>(obj, {info.bindablePropertyName}));
            builder.BindProperty();
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_ValueBuilder(PropertyInfo info)
		{
			if (symbol.IsSealed)
				GenerateExtensionMethod_ValueBuilder_Sealed(info);
			else
				GenerateExtensionMethod_ValueBuilder_Normal(info);
		}

		void GenerateExtensionMethod_ValueBuilder_Sealed(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            System.Func<ValueBuilder<{info.propertyTypeName}>, ValueBuilder<{info.propertyTypeName}>> buidValue)
        {{
            var builder = buidValue(new ValueBuilder<{info.propertyTypeName}>());
            if (builder.ValueIsSet()) obj.{info.propertyName} = builder.GetValue();
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_ValueBuilder_Normal(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T {info.propertyName}<T>(this T obj,
            System.Func<ValueBuilder<{info.propertyTypeName}>, ValueBuilder<{info.propertyTypeName}>> buidValue)
            where T : {info.symbolTypeName}
        {{
            var builder = buidValue(new ValueBuilder<{info.propertyTypeName}>());
            if (builder.ValueIsSet()) obj.{info.propertyName} = builder.GetValue();
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_LazyValueBuilder(PropertyInfo info)
		{
			if (symbol.IsSealed)
				GenerateExtensionMethod_LazyValueBuilder_Sealed(info);
			else
				GenerateExtensionMethod_LazyValueBuilder_Normal(info);
		}

		void GenerateExtensionMethod_LazyValueBuilder_Sealed(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            System.Func<LazyValueBuilder<{info.propertyTypeName}>, LazyValueBuilder<{info.propertyTypeName}>> buidValue)
        {{
            var builder = buidValue(new LazyValueBuilder<{info.propertyTypeName}>());
            if (builder.ValueIsSet()) obj.{info.propertyName} = builder.GetValue();
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_LazyValueBuilder_Normal(PropertyInfo info)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T {info.propertyName}<T>(this T obj,
            System.Func<LazyValueBuilder<{info.propertyTypeName}>, LazyValueBuilder<{info.propertyTypeName}>> buidValue)
            where T : {info.symbolTypeName}
        {{
            var builder = buidValue(new LazyValueBuilder<{info.propertyTypeName}>());
            if (builder.ValueIsSet()) obj.{info.propertyName} = builder.GetValue();
            return obj;
        }}
        ");
		}

		// -------------------------------
		// ----- list fluent methods -----    
		// -------------------------------

		void GenerateExtensionMethod_List(PropertyInfo info, string elementTypeName)
		{
			if (symbol.IsSealed)
				GenerateExtensionMethod_List_Sealed(info, elementTypeName);
			else
				GenerateExtensionMethod_List_Normal(info, elementTypeName);
		}

		void GenerateExtensionMethod_List_Sealed(PropertyInfo info, string elementTypeName)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            {info.propertyTypeName} {info.camelCaseName})
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}.Add(item);
            return obj;
        }}

        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            params {elementTypeName}[] {info.camelCaseName})
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}.Add(item);
            return obj;
        }}

        public static {info.symbolTypeName} {info.propertyName}(this {info.symbolTypeName} obj,
            System.Func<LazyValueBuilder<{info.propertyTypeName}>, LazyValueBuilder<{info.propertyTypeName}>> buidValue)
        {{
            var builder = buidValue(new LazyValueBuilder<{info.propertyTypeName}>());
            if (builder.ValueIsSet())
            {{
                var items = builder.GetValue();
                foreach (var item in items) 
                    {info.accessedWith}.{info.propertyName}.Add(item);
            }}
            return obj;
        }}
        ");
		}

		void GenerateExtensionMethod_List_Normal(PropertyInfo info, string elementTypeName)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T {info.propertyName}<T>(this T obj,
            {info.propertyTypeName} {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}.Add(item);
            return obj;
        }}

        public static T {info.propertyName}<T>(this T obj,
            params {elementTypeName}[] {info.camelCaseName})
            where T : {info.symbolTypeName}
        {{
            foreach (var item in {info.camelCaseName})
                {info.accessedWith}.{info.propertyName}.Add(item);
            return obj;
        }}

        public static T {info.propertyName}<T>(this T obj,
            System.Func<LazyValueBuilder<{info.propertyTypeName}>, LazyValueBuilder<{info.propertyTypeName}>> buidValue)
            where T : {info.symbolTypeName}
        {{
            var builder = buidValue(new LazyValueBuilder<{info.propertyTypeName}>());
            if (builder.ValueIsSet())
            {{
                var items = builder.GetValue();
                foreach (var item in items) 
                    {info.accessedWith}.{info.propertyName}.Add(item);
            }}
            return obj;
        }}
        ");
		}

		// --------------------------------
		// ----- event fluent methods -----    
		// --------------------------------

		void GenerateEventMethod(ISymbol @event)
		{
			var eventSymbol = (IEventSymbol)@event;
			var eventHandler = eventSymbol.AddMethod.Parameters.First();
			var eventHandlerType = ((INamedTypeSymbol)eventHandler.Type);

			var existInBases = false;
			Helpers.LoopDownToObject(symbol.BaseType, type =>
			{
				existInBases = (type
					.GetMembers()
					.FirstOrDefault(e =>
						e.Kind == SymbolKind.Event &&
						e.DeclaredAccessibility == Accessibility.Public &&
						e.Name.Equals(eventSymbol.Name, StringComparison.Ordinal)) != null);

				return existInBases;
			});

			if (!existInBases && !FluentGenerator.notGenerateList.Contains(eventSymbol.Name))
			{
				if (symbol.IsSealed)
				{
					GenerateEventMethodHandler_Sealed(eventSymbol, eventHandlerType);
					GenerateEventMethodNoArgs_Sealed(eventSymbol);
				}
				else
				{
					GenerateEventMethodHandler_Normal(eventSymbol, eventHandlerType);
					GenerateEventMethodNoArgs_Normal(eventSymbol);
				}
			}
		}

		void GenerateEventMethodHandler_Sealed(IEventSymbol eventSymbol, INamedTypeSymbol namedType)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {symbol.ToDisplayString()} On{eventSymbol.Name}(this {symbol.ToDisplayString()} obj, {namedType.ToDisplayString()} handler)
        {{
            obj.{eventSymbol.Name} += handler;
            return obj;
        }}
        ");
		}

		void GenerateEventMethodHandler_Normal(IEventSymbol eventSymbol, INamedTypeSymbol namedType)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T On{eventSymbol.Name}<T>(this T obj, {namedType.ToDisplayString()} handler)
            where T : {symbol.ToDisplayString()}
        {{
            obj.{eventSymbol.Name} += handler;
            return obj;
        }}
        ");
		}

		void GenerateEventMethodNoArgs_Sealed(IEventSymbol eventSymbol)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static {symbol.ToDisplayString()} On{eventSymbol.Name}(this {symbol.ToDisplayString()} obj, System.Action<{symbol.ToDisplayString()}> action)
        {{
            obj.{eventSymbol.Name} += (o, arg) => action(obj);
            return obj;
        }}
        ");
		}

		void GenerateEventMethodNoArgs_Normal(IEventSymbol eventSymbol)
		{
			isExtensionMethodsGenerated = true;
			builder.Append($@"
        public static T On{eventSymbol.Name}<T>(this T obj, System.Action<T> action)
            where T : {symbol.ToDisplayString()}
        {{
            obj.{eventSymbol.Name} += (o, arg) => action(obj);
            return obj;
        }}
        ");
		}
	}
}

